import { supabase } from "@/integrations/supabase/client";

export interface AdminAppointment {
  id: string;
  confirmation_number: string;
  customer_id: string | null;
  guest_name: string | null;
  guest_email: string | null;
  guest_phone: string | null;
  barber_id: string | null;
  service_id: string;
  appointment_date: string;
  appointment_time: string;
  status: 'pending' | 'confirmed' | 'completed' | 'cancelled' | 'no_show';
  payment_status: 'none' | 'deposit_paid' | 'fully_paid';
  payment_amount: number | null;
  notes: string | null;
  created_at: string;
  updated_at: string;
  barbers?: { full_name: string } | null;
  services?: { name: string; regular_price: number } | null;
  customer_name?: string | null;
}

// Get all appointments with related data
export const getAllAppointments = async (): Promise<AdminAppointment[]> => {
  const { data, error } = await supabase
    .from('appointments')
    .select(`
      *,
      barbers(full_name),
      services(name, regular_price)
    `)
    .order('appointment_date', { ascending: false })
    .order('appointment_time', { ascending: false });

  if (error) throw error;
  
  // Fetch customer names for registered users
  const appointmentsWithCustomers = await Promise.all(
    (data || []).map(async (apt: any) => {
      if (apt.customer_id) {
        const { data: profile } = await supabase
          .from('profiles')
          .select('full_name')
          .eq('id', apt.customer_id)
          .maybeSingle();
        
        return {
          ...apt,
          customer_name: profile?.full_name || null,
        };
      }
      return { ...apt, customer_name: null };
    })
  );
  
  return appointmentsWithCustomers as AdminAppointment[];
};

// Create appointment manually (admin only)
export const createManualAppointment = async (appointmentData: {
  customer_id: string | null;
  guest_name?: string;
  guest_email?: string;
  guest_phone?: string;
  barber_id: string;
  service_id: string;
  appointment_date: string;
  appointment_time: string;
  notes?: string;
  payment_amount?: number;
  payment_status?: 'none' | 'deposit_paid' | 'fully_paid';
  status?: 'pending' | 'confirmed' | 'completed' | 'cancelled' | 'no_show';
}) => {
  // confirmation_number is auto-generated by database trigger
  const { data, error } = await supabase
    .from('appointments')
    .insert([appointmentData as any])
    .select()
    .single();

  if (error) throw error;
  return data;
};

// Update appointment status
export const updateAppointmentStatus = async (
  id: string,
  status: 'pending' | 'confirmed' | 'completed' | 'cancelled' | 'no_show'
) => {
  const { error } = await supabase
    .from('appointments')
    .update({ status })
    .eq('id', id);

  if (error) throw error;
};

// Update appointment payment status
export const updatePaymentStatus = async (
  id: string,
  payment_status: 'none' | 'deposit_paid' | 'fully_paid'
) => {
  const { error } = await supabase
    .from('appointments')
    .update({ payment_status })
    .eq('id', id);

  if (error) throw error;
};

// Get all customers (profiles)
export const getAllCustomers = async () => {
  const { data, error } = await supabase
    .from('profiles')
    .select('*')
    .order('full_name', { ascending: true });

  if (error) throw error;
  return data || [];
};

// Get all users with their roles
// Note: This function requires creating an edge function to get user emails
// since auth.users is not accessible from the client
export const getAllUsers = async () => {
  const { data: profiles, error: profilesError } = await supabase
    .from('profiles')
    .select('id, full_name, phone, created_at');

  if (profilesError) throw profilesError;

  // Get roles for each user
  const usersWithRoles = await Promise.all(
    (profiles || []).map(async (profile) => {
      const { data: roleData } = await supabase
        .from('user_roles')
        .select('role')
        .eq('user_id', profile.id)
        .maybeSingle();

      return {
        ...profile,
        email: null, // Email will be populated via edge function if needed
        role: roleData?.role || 'customer',
      };
    })
  );

  return usersWithRoles;
};

// Update user role
export const updateUserRole = async (
  userId: string,
  newRole: 'admin' | 'barber' | 'customer'
) => {
  // Delete existing role
  await supabase
    .from('user_roles')
    .delete()
    .eq('user_id', userId);

  // Insert new role
  const { error } = await supabase
    .from('user_roles')
    .insert({
      user_id: userId,
      role: newRole,
    });

  if (error) throw error;
};

// Create admin account via edge function
export const createAdminAccount = async (
  email: string,
  password: string,
  fullName: string
) => {
  const { data, error } = await supabase.functions.invoke('create-admin-account', {
    body: { email, password, fullName },
  });

  if (error) throw error;
  return data;
};

// Promote existing user to admin (for first admin setup)
export const promoteToAdmin = async (email: string) => {
  const { data, error } = await supabase.rpc('promote_user_to_admin', {
    target_email: email,
  });

  if (error) throw error;
  return data;
};

// Get all barbers
export const getAllBarbers = async () => {
  const { data, error } = await supabase
    .from('barbers')
    .select('*')
    .order('full_name', { ascending: true });

  if (error) throw error;
  return data || [];
};

// Create barber account via edge function
export const createBarberAccount = async (barberData: {
  email: string;
  password: string;
  fullName: string;
  bio?: string;
  specialties?: string[];
  yearsExperience?: number;
  profileImageUrl?: string;
}) => {
  const { data, error } = await supabase.functions.invoke('create-barber-account', {
    body: barberData,
  });

  if (error) throw error;
  return data;
};

// Upload barber profile image
export const uploadBarberImage = async (file: File, barberId: string): Promise<string> => {
  const fileExt = file.name.split('.').pop();
  const fileName = `barber-${barberId}-${Date.now()}.${fileExt}`;

  const { error: uploadError } = await supabase.storage
    .from('avatars')
    .upload(fileName, file, {
      cacheControl: '3600',
      upsert: true,
    });

  if (uploadError) throw uploadError;

  const { data } = supabase.storage
    .from('avatars')
    .getPublicUrl(fileName);

  return data.publicUrl;
};

// Update barber profile
export const updateBarberProfile = async (
  barberId: string,
  updates: {
    full_name?: string;
    bio?: string;
    specialties?: string[];
    years_experience?: number;
    profile_image_url?: string;
    is_active?: boolean;
    status_message?: string | null;
  }
) => {
  const { error } = await supabase
    .from('barbers')
    .update(updates)
    .eq('id', barberId);

  if (error) throw error;
};

// Delete barber (soft delete by setting is_active to false)
export const deleteBarber = async (barberId: string) => {
  const { error } = await supabase
    .from('barbers')
    .update({ is_active: false })
    .eq('id', barberId);

  if (error) throw error;
};

// Get barber availability
export const getBarberAvailability = async (barberId: string) => {
  const { data, error } = await supabase
    .from('barber_availability')
    .select('*')
    .eq('barber_id', barberId)
    .order('day_of_week', { ascending: true });

  if (error) throw error;
  return data || [];
};

// Update barber availability
export const updateBarberAvailability = async (
  barberId: string,
  availability: Array<{
    day_of_week: number;
    start_time: string;
    end_time: string;
    is_available: boolean;
    status_message?: string;
  }>
) => {
  // Delete existing availability
  await supabase
    .from('barber_availability')
    .delete()
    .eq('barber_id', barberId);

  // Insert new availability
  const { error } = await supabase
    .from('barber_availability')
    .insert(
      availability.map(a => ({
        barber_id: barberId,
        ...a,
      }))
    );

  if (error) throw error;
};

// Get available time slots for a barber on a specific date
export const getAvailableTimeSlots = async (
  barberId: string,
  date: string,
  serviceDuration: number
): Promise<string[]> => {
  // Get barber's availability for the day of week
  const dayOfWeek = new Date(date).getDay();
  
  const { data: availability, error: availError } = await supabase
    .from('barber_availability')
    .select('*')
    .eq('barber_id', barberId)
    .eq('day_of_week', dayOfWeek)
    .eq('is_available', true)
    .single();

  if (availError || !availability) return [];

  // Get existing appointments for that barber on that date
  const { data: appointments, error: apptError } = await supabase
    .from('appointments')
    .select('appointment_time, services(duration_minutes)')
    .eq('barber_id', barberId)
    .eq('appointment_date', date)
    .neq('status', 'cancelled');

  if (apptError) return [];

  // Generate time slots
  const slots: string[] = [];
  const startTime = new Date(`2000-01-01T${availability.start_time}`);
  const endTime = new Date(`2000-01-01T${availability.end_time}`);
  
  let currentTime = startTime;
  while (currentTime < endTime) {
    const timeString = currentTime.toTimeString().slice(0, 5);
    
    // Check if slot is available (not overlapping with existing appointments)
    const isAvailable = !appointments?.some((apt: any) => {
      const aptTime = new Date(`2000-01-01T${apt.appointment_time}`);
      const aptDuration = apt.services?.duration_minutes || 30;
      const aptEnd = new Date(aptTime.getTime() + aptDuration * 60000);
      
      const slotTime = new Date(`2000-01-01T${timeString}`);
      const slotEnd = new Date(slotTime.getTime() + serviceDuration * 60000);
      
      // Check for overlap
      return slotTime < aptEnd && slotEnd > aptTime;
    });
    
    if (isAvailable) {
      slots.push(timeString);
    }
    
    // Move to next slot (30-minute intervals)
    currentTime = new Date(currentTime.getTime() + 30 * 60000);
  }
  
  return slots;
};
